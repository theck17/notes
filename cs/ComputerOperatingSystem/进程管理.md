---
title: '进程管理'
date: 2020-05-01 11:36:41
tags: [Operating System]
published: true
hideInList: false
feature: /post-images/jin-cheng-guan-li.jpg

---

[TOC]

# 进程管理

## 线程与进程

### 进程概念和特征 

* 进程实体（进程映像）的组成
    * PCB：PCB是进程存在的唯一标志
    * 程序段：程序代码
    * 数据段：运行过程中产生的数据

* 进程的特征
    * 动态性（基本特性）、并发性、独立性、异步性、结构性

### 进程的状态与转换

* 运行态、就绪态、阻塞态、创建态、结束态
* 就绪态-->运行态：进程被调度，分配时间片、获得处理机资源
* 运行态-->就绪态：时间片用完下处理机
* 运行态-->阻塞态（主动）：进程请求某一资源的使用和分配或等待某一事件的发生
* 阻塞态-->就绪态（被动）：进程等待的事件到来时
* 进程的组织方式
    * 链接方式
    * 索引方式

###  进程控制

* 实现进程控制的转换，原语实现，使用“开中断”和"关中断""两个特权指令实现原子性
* 进程创建
    * 申请空白PCB
    * 为进程分配资源
    * 初始化PCB
    * 将PCB插入就绪队列
* 进程终止
    * 找到进程的PCB
    * 若进程正在运行，立即剥夺CPU使用权
    * 终止其所有子进程
    * 将进程资源还给父进程或操作系统
    * 删除PCB
    * 引起进程终止的事件：正常结束、异常结束、外界干预
* 进程阻塞和唤醒
    * 找到进程PCB
    * 若进程为运行态，保护其现场，状态转为阻塞态，停止运行
    * 将PCB插入响应事件的等待队列
    * 在等待队列找到对应进程的PCB
    * 将状态改为就绪态
    * 把PCB放到就绪队列
    * 阻塞原语和唤醒原语必须成对出现
* 进程切换
    * 找到PCB移入相应队列
    * 选择另一个进程执行，并更新其PCB
    * 根据PCB恢复新进程所需的运行环境
    * 引起进程切换的事件
        * 时间片用完
        * 更高优先级进程到达
        * 进程主动阻塞
        * 当前进程终止

### 进程通信

* 共享存储
    * 基于数据结构的共享
    * 基于存储区的共享

* 消息传递
    * 直接通信方式
    * 间接通信方式
* 管道通信

### 线程

* 线程的概念的特点
    * 引入进程的目的是使多道程序并发执行，提高资源利用率和系统吞吐量
    * 引入线程的目的是减小程序在并发时的时空开销，提高系统并发性能
* 进程与线程的比较
* 线程属性
* 线程实现方式
    * 用户级线程：应用程序的线程库完成，操作系统看到的还是进程
        * 优点：需要CPU切换状态，效率高
        * 缺点：其中一个阻塞，整个进程都会阻塞
    * 内核级线程
        * 优点：并发能力强
        * 缺点：切换线程需要CPU状态转换，开销大

## 处理机调度

### 调度的层次

* 高级调度（作业调度）
    * 分时系统无需作业调度，因为需要交互
    * 批处理系统需要作业调度
* 中级调度（内存调度）
* 低级调度（进程调度）

### 进程调度的时机、切换与过程

* 进程调度的时机
    * 进程主动放弃处理机：异常、终止、阻塞
    * 进程被动放弃处理机：时间片用完，更紧急的或优先级更高的事件要处理
    * 不能进行进程调度的情况
        * 处理中断的过程中
        * 进程在**操作系统内核程序临界区**中
            * 临界资源：一段时间只允许一个进程使用的资源，各个进程需要互斥访问
            * 临界区：访问临界资源的代码
            * 内核程序临界区：一般是用来访问内核数据结构的，比如就绪队列
        * 在原子操作过程中（原语）
* 进程切换和进程调度
* 方式
    * 非剥夺调度方式（非抢占式）：只允许进程会自动放弃处理机
    * 剥夺调度方式（抢占式）：优先处理更紧急的任务

### 调度算法的评价指标

* CPU利用率：CPU忙碌的时间/总时间
* 系统吞吐量：单位时间内完成了多少作业，总作业数/总时间
* 周转时间
    * 周转时间：作业完成时间-作业提交时间
    * 平均周转时间：各个作业的周转时间之和/作业数
    * 带权周转时间：作业周转时间/作业实际运行时间
    * 平均带权周转时间：各个作业的带权周转时间之和/作业数
* 等待时间：作业等待处理机处理的时间之和
* 响应时间：从用户提交请求到首次产生响应的时间

### 调度算法

* 先来先服务（FCFS）
    * 非抢占式算法
    * 优点：公平，实现简单
    * 缺点：带权周转时间场，用户体验不好
    * 不会导致饥饿
* 短作业优先（SJF）、短进程优先（SPF）
    * 非抢占式算法
    * 抢占式版本：最短剩余时间优先算法（SRTN），每次有新作业到达比较剩余时间，剩余时间短的优先
    * 优点：最短的平均等待时间和平均周转时间（不一定）
    * 缺点：不公平、进程运行时间由用户提供，不一定真实
    * 可能导致饥饿
* 高响应比优先（HRRN）
    * 规则：每次调度前先计算进程响应比，响应比最高的优先服务
    * 响应比 = （等待时间+要求服务时间）/要求服务时间
    * 非抢占式算法
    * 不会导致饥饿
* 时间片轮转调度算法（RR）
    * 只用于进程调度（只有作业放入内存建立了响应进程后，才能被分配处理机时间片）
    * 抢占式算法
    * 优点：公平、响应快、适用于分时操作系统
    * 缺点：切换进程有一定开销、不区分任务紧急程度
    * 不会导致饥饿
* 优先级调度算法
    * 作业调度、进程调度
    * 抢占式、非抢占式都有
    * 优先级：静态优先级、动态优先级
        * 系统进程>用户进程
        * 前台进程>后台进程
        * I/O繁忙型进程>CPU繁忙型进程
    * 优点：按优先级区分紧急程度，适用于实时操作系统
    * 缺点：若一直有高优先级进程到来，可能导致饥饿
    * 可能导致饥饿
* 多级反馈队列调度算法
    * 用于进程调度
    * 抢占式算法
    * 优点：相对公平
    * 可能导致饥饿

## 作业与作业调度

### 作业

* 作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。

### 作业控制块JCB

* 为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。

### 作业步

* 作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。

### 作业运行的三个阶段

* 收容阶段
* 运行阶段
* 完成阶段

### 作业运行的三个状态

* 后备状态
* 运行状态
* 完成状态

### 作业调度的主要任务

* 接纳多少个作业
* 接纳哪些作业

## 实时调度(HRT和SRT任务)

### 实现实时调度的基本条件

* 提供必要信息
    * 就绪时间
    * 开始截止时间和完成截止时间
    * 处理时间
    * 资源要求
    * 优先级
* 系统处理能力强
    * ∑(Ci/Pi)≤1
    * N个处理机:∑(Ci/Pi)≤N
* 采用抢占式调度机制
* 具有快速切换机制
    * 对中断的快速响应能力
    * 快速的任务分派能力

### 实时调度算法的分类

* 非抢占式调度算法
    * 非抢占式轮转调度算法
    * 非抢占式优先调度算法
* 抢占式调度算法
    * 基于时钟中断的抢占式优先级调度算法
    * 立即抢占的优先级调度算法

### 最早截止时间优先EDF(Earliest Deadline First)算法

* 根据任务的开始截至时间来确定任务的优先级
    * 截至时间越早，优先级越高
* 非抢占式调度方式用于非周期实时任务
* 抢占式调度方式用于周期实时任务

### 最低松弛度优先LLF(Least Laxity First)算法

* 类似EDF
* 算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。
* 松弛度例子
    * 例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms

### 优先级倒置(Priority inversion problem)

* 优先级倒置的形成
    * 高优先级进程被低优先级进程延迟或阻塞。
* 优先级倒置的解决方法
    * 简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占
    * 实用的:建立在动态优先级继承基础上的

## 进程同步

###  进程同步概念

* 异步性：各个并发执行的进程以各自独立的、不可预知的速度向前推进

* 进程同步：直接制约关系，进程间相互制约，目的是解决进程异步的问题

* 进程互斥：间接制约关系，访问临界资源

    * 资源共享方式

        * 互斥共享：一段时间内只允许一个进程访问
        * 同时共享：一段时间内允许多个进程交替访问

    * 四个部分

        * 进入区：检查是否可进入临界区，如可进入，需要上锁

        * 临界区：访问临界资源的代码

        * 退出区：解锁

        * 剩余区：其余代码

        * ```c
            do{
                entry section;//进入区
                critical section;//临界区
                exit section;//退出区
                remainder rection;//剩余区
            }while (true)
            ```

* 进程互斥访问原则

    * 空闲让进
    * 忙则等待
    * 有限等待
    * 让权等待

### 进程互斥的软件实现方法

* 单标志法

    * 算法思想：一个进程在访问完临界区后会把临界区的权限交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予

    * 违背“空闲让进”原则

    * ```c
        int turn = 0;//turn表示当前允许进入临界区的进程号
        ```

* 双标志先检查法

    * 算法思想：设置一个布尔型数组flag[]，数组中的各个元素用来**标记各个进程想进入临界区的意愿**，比如flag[0]=true意味着0号进程P0想要进入临界区，每个进程在进入临界区之前会检查有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]=true，开始访问临界区，访问结束后，将flag[i]=false

    * 违背“忙则等待”原则

    * ```c
        bool flag[2]; //表示进入临界区意愿的数组
        flag[0] = false;
        flag[1] = false;//开始设置连个进程都不想进入临界区
        //P0
        while(flag[1]);
        flag[0]=true;
        critical section;
        flag[0]=false;
        remainder section;
        //P1
        while(flag[0]);
        flag[1]=true;
        critical section;
        flag[1]=false;
        remainder section;
        ```

* 双标志后检查法

    * 算法思想：改进了双标志先检查法，前一个算法的问题是先检查后上锁，但是两个操作无法保证原子性，会导致两个进程同时访问临界区，因此提出先上锁后检查的方法

    * 解决了“忙则等待”的问题，违背了“空闲让进”和“有限等待”原则，会产生“饥饿”现象

    * ```c
        bool flag[2];
        flag[0] = false;
        flag[1] = false;
        //P0
        flag[0]=true;
        while(flag[1]);
        critical section;
        flag[0]=false;
        remainder section;
        //P1
        flag[1]=true;
        while(flag[0]);
        critical section;
        flag[1]=false;
        remainder section;
        ```

* Peterson算法

    * 双标志后检查法中，两个进程都想进入临界区，会导致都进不去，这是可以主动让对方先进

    * 为遵循“让权等待”原则，会发生“忙等”

    * ```c
        bool flag[2];
        int turn = 0;//turn表示优先让哪个进程进入临界区
        //P0
        flag[0]=true;
        turn=1;
        while(flag[1] && turn==1);
        critical section;
        flag[0]=false;
        remainder section;
        //P1
        flag[1]=true;
        turn = 0;
        while(flag[0] && turn==0);
        critical section;
        flag[1]=false;
        remainder section;
        ```

        
        

### 进程互斥的硬件实现方法

* 中断屏蔽

    * ```c
        关中断;
        临界区;
        开中断;
        ```

    * 优点：简单高效

    * 缺点：

        * 开中断关中断指令只对执行的那个处理机有用，不适用于多处理机的情况；
        * 开中断关中断指令只能运行在内核态，只适用于系统内核进程，不适用于用户进程

* TestAndSet/TestAndSetLock（TS指令/TSL指令）

    * 指令由硬件实现，不可中断
    * 优点：实现简单，适用于多处理机
    * 缺点，不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环，导致“忙等”

* Swap指令

    * 也叫Exchange（XCHG）指令
    * 由硬件实现，不可中断
    * 优点：实现简单，适用于多处理机
    * 缺点，不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环，导致“忙等”

### 信号量机制

* 用户可以通过操作系统提供的**一对原语**对**信号量**进行操作，从而实现进程互斥、进程同步
* 信号量其实是一个变量，可以是**一个整数**也可以是更复杂的记录型信号量，可以用一个信号量来**表示系统中的某种资源**，比如系统中只有一台打印机、就可以设置一个值为1的信号量

* 一对原语

    * wait(S)原语和Signal(S)原语，可以理解为自己写的函数，S为传入参数
    * 简称为P,V操作，wait(S)、Signal(S)可以简写为P(S)、V(S)

* 整型信号量

    * 用一个整数作为信号量，表示系统中的某种资源

    * ```c
        int S = 1;
        void wait(int S){//wait原语，相当于进入区
            while (S<=0);//如果资源数不够，一直循环等待
            S=S-1;//资源数够了，占用一个资源
        }
        void signal(int S){//signal原语，相当于退出区
            S=S+1;//使用完资源，在退出去释放资源
        }
        //进程P0
        wait(S);
        使用资源;
        signal(S);
        ```

    * 存在“忙等”问题

* 记录型信号量

    * ```c
        //记录型信号量
        typeof struct {
            int value;//剩余资源数
            struct process *L;//等待队列
        } semaphore;
        //wait
        void wait (semaphore S){
            S.value--;
            if (S.value<0){
                //剩余数不够使用block原语使进程进入阻塞，并挂到信号量S的阻塞队列中
                block (S.L);
            }
        }
        //signal
        void signal (semaphore S){
            S.value++;
            if (S.value<=0){
                //释放资源后，用wakeup原语唤醒阻塞队列中的一个进程，变为就绪态
                wakeup(S.L);
            }
        }
        ```

* 信号量实现进程同步

    * 前V后P

* 信号量实现进程互斥

    * 前P后V

* 信号量实现前驱关系

    * 前V后P

### 经典同步问题

* 生产者-消费者问题
* 多生产者-多消费者问题
* 读者-写者问题
* 哲学家进餐问题
* 吸烟者问题

### 管程

* 管程是一种特殊的软件模式
    * 局部于管程的共享数据结构说明
    * 对改数据结构进行操作的一组过程
    * 对局部于管程的共享数据设置初始值的语句
    * 管程有一个名字
* 管程的基本特征
    * 局部于管程的数据只能被局部于管程的过程所访问
    * 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    * 每次仅允许一个进程在管程内执行某个内部过程

## 死锁概述

### 资源问题

* 可重用性资源
    * 计算机外设
* 消耗性资源
    * 数据，消息
* 可抢占性资源
    *  不引起死锁
    *  CPU，内存 
* 不可抢占性资源
    * 光驱，打印机

### 计算机系统中的死锁

* 竞争不可抢占性资源引起死锁
* 竞争可消耗资源引起死锁
* 进程推进顺序非法引起死锁
* 信号量的使用不当

### 死锁、饥饿、死循环

* 死锁：至少两个进程一起死锁，死锁进程处于阻塞态
* 饥饿：可以只有一个进程饥饿，即得不到想要的资源，饥饿进程可能阻塞也可看就绪
* 死循环：可以是只有一个进程发生死循环，死循环进程可上处理机

### 死锁的定义，必要条件

* 定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的
* 产生死锁的必要条件
    * 互斥条件
    * 请求和保存条件
    * 不可剥夺条件
    * 循环等待条件
        * 如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件

### 处理死锁

* 预防死锁

    * 静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。
    * 预防死锁的策略
        * 破坏"请求和保存"条件
            * 第一种协议
                * 所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源
                * 优点:简单，易行，安全
                * 缺点
                    * 资源被严重浪费，严重地恶化了资源的利用率
                    * 使进程经常会发生饥饿现象
            * 第二种协议
                * 它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源
        * 破坏不可剥夺条件
            * 当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请
        * 破坏互斥条件：有些资源必须互斥使用，无法破坏互斥条件
        * 破坏"循环等待"条件
            * 对系统所以资源类型进行线性排序，并赋予不同的序号
            * 例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。

* 避免死锁

    * 安全序列

    * 动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法
    * 避免死锁的策略
        * 系统安全状态
            * 安全状态
                * 某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如<p1,p2…pn>来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列
            * 安全状态之例
            * 由安全状态向不安全状态的转换
        * 利用银行家算法避免死锁
            * 含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待
            * 银行家算法中的数据结构
                * 可用资源向量 Available[m]：m为系统中资源种类数，Available[j]=k表示系统中第j类资源数为k个。
                * 最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]=k表示进程i对j类资源的最大需求数为中k。
                * 分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。
                * 需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]=k 表示进程i   还需要j类资源k个。Need[i,j]=Max[i,j] - Allocation[i,j]

* 检测死锁：利用死锁定理化简资源分配图以检测死锁的存在

    * 死锁的检测
        * 资源分配图
            * 简化步骤
                * 选择一个没有阻塞的进程p
                * 将p移走，包括它的所有请求边和分配边
                * 重复步骤1，2，直至不能继续下去
        * 死锁定理
            * 若一系列简化以后不能使所有的进程节点都成为孤立节点
        * 检测时机
            *  当进程等待时检测死锁 （其缺点是系统的开销大）
            *  定时检测
            *  系统资源利用率下降时检测死锁
        * 死锁检测中的数据结构

* 死锁的解除

    * 资源剥夺法：挂起某些死锁的进程并抢夺它的资源，以便让其他进程继续推进
    * 终止进程法
        * 终止进程的方法
            * 终止所有死锁进程
            * 逐个终止进程
                * 代价最小
                    * 进程的优先级的大小
                    * 进程已执行了多少时间，还需时间
                    * 进程在运行中已经使用资源的多少，还需多少资源
                    * 进程的性质是交互式还是批处理的
    * 进程回退法：让一个或多个进程回退到足以避免死锁的地步
    * 付出代价最小的死锁解除算法
        * 是使用一个有效的挂起和解除机构来挂起一些死锁的进程

    