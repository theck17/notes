---
title: '内存管理'
date: 2020-05-02 17:18:05
tags: [Operating System]
published: true
hideInList: false
feature: /post-images/nei-cun-guan-li.jpg
isTop: false
---
[TOC]

# 内存管理

## 内存管理概念

### 基本原理

* 过程
    * 编译：源代码到目标模块
    * 链接：目标模块到装入模块、完整的逻辑地址
    * 装入：装入模块装入内存，装入后形成物理地址
* 链接方式：静态链接、装入时动态链接、运行时动态链接
* 装入方式：绝对装入、静态重定位、动态重定位

### 内存管理概念

* 内存的分配与回收：
    * 连续分配管理
    * 非连续分配管理
* 内存空间的扩展：覆盖技术、交换技术、虚拟存储技术
* 地址转换：三种装入方式，负责程序逻辑地址和物理地址的转换
* 内存保护：操作系统需要保证各道作业在各自的存储空间内运行，互不干扰
    * 设置上、下限寄存器
    * 采用重定位寄存器、界地址寄存器

### 覆盖与交换

* 覆盖技术思想：将程序分为多个段，常用的放到固定区，不常用的放到覆盖区
    * 对用户不透明，增加编程负担
* 交换技术思想：内存空间紧张时，系统将内存中的某些进程暂时换出外存，把外存中某些具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）

### 连续分配管理方式

* 单一连续分配
    * 系统区：存放操作系统相关数据
    * 用户区：存放进程相关数据
    * 优点：简单、无外部碎片、可用覆盖技术扩充内存
    * 缺点：只能用于单用户单任务的操作系统，有内部碎片，存储器利用率低
* 固定分区分配：划分为若干个固定大小的分区，每个分区只能装入一道作业
    * 需要建立一个分区说明表，记录分区的大小、起始地址、状态
    * 分区大小相等：缺乏灵活性
    * 分区大小不等：增加灵活性
    * 优点：实现简单、无外部碎片
    * 缺点：有内部碎片
* 动态分区分配
    * 又称为可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的
    * 无内部碎片，有外部碎片
    * 首次适应（First Fit）算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小满足要求的第一个空闲分区
    * 最佳适应（Best Fit）算法：空闲分区按容量递增的方式形成分区链，找到第一个能满足要求的空闲分区
    * 是坏适应（Worst Fit）算法：又称最大适应算法，空闲分区一容量递减的次序链接，找到第一个能满足要求的空闲分区，即挑选出最大的分区
    * 邻近适应（Next Fit）算法：又称循环首次适应算法，由首次事情算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找

### 非连续分配管理方式

* 基本分页存储管理
    * 内存分为一个个大小相等的分区
        * 页框=页帧=内存块=物理块=物理页面
        * 页框号=页帧号=内存块号=物理块号=物理页号
    * 进程的逻辑地址分为与页框大小相等的一个个部分
        * 页=页面
        * 页号=页面号=逻辑地址%页面长度（取余）
        * 页号=逻辑地址/页面长度（取整）
    * 页表
        * 页表记录了页面和实际存放的内存块之间的映射关系
        * 一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成
        * 每个页表项是大小相同，页号是“隐含”的
        * i的页表项项存放地址 = 页表初始地址 + i*页表项大小
    * 逻辑地址结构：可拆分为页号P、页内偏移量W
        * 页号P = 逻辑地址/页面大小
        * 页内偏移量W = 逻辑地址%页面大小
        * 如果页面大小刚好是2的整数次幂的情况特殊
    * 如何实现逻辑地址和物理地址转换
        * 计算出逻辑地址对应的页号、页内偏移量
        * 找到对应页面在内存中存放的位置（查页表）
        * 物理地址 = 页面始址 + 页内偏移量
    * 基本地址变换机构
        * 页表寄存器作用：1、存放页表起始地址；2、存放页表长度
        * 地址变换过程
            * 1、根据逻辑地址算出页号、页内偏移量
            * 2、页号的合法性检查（与页表长度对比）
            * 3、若也好合法，再根据页表起始地址、页号找到对应的页表项
            * 4、根据页表项中记录的内存块号、页内偏移量得到最终的物理地址
            * 5、物理地址内存对应的内存单元
        * 其他细节
            * 页内偏移量位数与页面大小之间的关系
            * 页式管理中地址是一维的
            * 实际应用中，通常一个页框恰好能放入整个页表项
    * 具有快表的地址变换机构
        * 快表（TLB），又称联想寄存器（TLB）,是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项副本，可以加速地址变换速度。
        * 与此对应的，内存中的页表常称为慢表
        * 局部性原理：时间局部性、空间局部性
    * 两级页表
        * 单级页表存在问题：
            * 1、所有页表项必须连续存放，页表过大时需要很大连续空间
            * 2、一段时间内并非所有页面都要用到，因此没必要让整个页表常驻内存
        * 逻辑地址 = 一级页号+二级页号+页内偏移量
* 基本分段存储管理
    * 分段
        * 段号（段名）+ 段内地址（段内偏移量）
        * 段号的位数决定了每个进程最多可以分多少个段
        * 段内地址的位数决定了每个段的最大长度是多少
    * 段表：段号、段长、基址
        * 记录逻辑段到实际存储地址的关系
        * 每个段对应一个段表项，段表项长度相同（段号、段长、基址）
    * 地址变换
        * 1、有逻辑地址得到段号、段内地址
        * 2、段号与段表寄存器中的段长度比较，检查是否越界
        * 3、由段表始址、段号找到相应的段表项
        * 4、根据段表中记录的段长，检查段内地址是否越界
        * 5、由段表中的“基址+段内地址”得到最终物理地址
        * 6、访问目标单元
    * 分段与分页对比
        * 分段比分页更容易实现信息的共享和保护
        * 页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存利用率，系统行为对用户不可见
        * 段是信息的逻辑单位，分段的主要目的是更好的满足用户需求，一个单通常包含这一组属于一个逻辑模块的信息，分段对用户可见，用户编程时需要显式的给出段名
        * 也的大小有系统决定，段的长度由用户决定
        * 分页的用户进程地址空间是一维的，程序员只需要给出一个记忆符即可表示一个地址
        * 分段的用户进程地址空间是二维的，程序员需要给出段名和段内地址
    * 地址变换机构
    * 段的共享与保护
* 段页式存储管理
    * 分段+分页
        * 将地址空间按照程序自身的逻辑关系划分多个段，每个段分为大小相等的页
        * 将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存
        * 逻辑地址结构：段号、页号、页内偏移量
    * 段表、页表
        * 每个段对应一个段表项，各个段表项长度相同，由段号、页表长度、页表存放地址组成
        * 每个页对应一个页表项，各个页表项长度相同，由页号、页面存放的内存块号租场
    * 地址变换
        * 1、有逻辑地址得到段号、页号、页内偏移量
        * 2、段号与段表寄存器中的段长度比较检查是否越界
        * 3、由段表始址、段号找到对应段表项
        * 4、根据段表中记录的页表长度检查页号是否越界
        * 5、由段表中的页表地址、页号查询页表，得到相应的页表项
        * 6、有页面存放的内存块号、页内偏移量得到最终物理地址
        * 7、访问目标单元

## 虚拟内存

### 概念

* 传统存储管理方式的缺点：一次性、驻留性
* 局部性原理
    * 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据北方问过，不久之后改数据很有可能再次被访问
    * 空间局部性：一旦程序访问了某个存储单元，那么不久后，其附近的存储单元也很有可能被访问，因为很多数据在内存中都是连续存放的，并且程序指令也是顺序的在内存中存放的
    * 高速缓存技术：使用频繁的数据放到高速缓存中
* 虚拟内存定义和特征
    * 程序不需要全部装入即可运行，运行时根据需要动态调入数据，换出数据
    * 特征：多次性、对换性、虚拟性
* 如何实现虚拟技术
    * 请求调页功能
    * 页面置换功能
    * 实现
        * 请求分页存储管理
        * 请求分段存储管理
        * 请求段页式存储管理

### 页面置换算法

* 最佳置换算法（OPT）：每次选择淘汰的页面将是以后永不再使用，或者是最长时间内不再访问的页面，这样可以保证最低缺页率
    * 缺页率小、性能好，但无法实现
* 先进先出置换算法（FIFO）：每次选择淘汰的页面时最早进入内存的页面
    * 实现简单、性能差，会产生Belady异常
    * Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常，只有FIFO算法会产生Belady异常
* 最近最久未使用置换算法（LRU）：每次淘汰的页面时最近最久未使用的页面
    * 最接近OPT算法，但是实现困难，开销大
* 时钟置换算法（CLOCK）：循环扫描各个页面，第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1，若第一轮没选中，则进行第二轮扫描
    * 为考虑页面是否被修改的问题
* 改进型的时钟置换算法：（访问位，修改位）
    1. 第一轮淘汰（0,0）
    2. 第二轮淘汰（0,1），并将扫描过的页面访问位都改为0
    3. 第三轮淘汰（0,0）
    4. 第四轮淘汰（0,1）

### 请求分页管理方式

* 页表机制

    * | 页号 | 物理块号 | 状态位P | 访问字段A | 修改位M | 外存地址 |
        | ---- | -------- | ------- | --------- | ------- | -------- |
        |      |          | NEW     | NEW       | NEW     | NEW      |

    * 状态位：表示页面是否已在内存中

    * 访问字段：记录最近被访问过几次，或上次访问时间

    * 修改位：记录页面是否被修改过

    * 外存地址：页面在外存中存放的位置

* 缺页中断机构

    * 找到页表项后检查页面是否已经在内存，如没有，产生缺页中断
    * 缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面
    * 缺页中断属于内中断，属于内中断中的“故障”，即可能被系统修复的异常
    * 一条指令在执行过程中可能产生多次缺页中断

* 地址变换机构

    * 找到页表项是需要检查页面是否在内存中
    * 如页面在内存中，需要请求调页
    * 如内存地址不够，还需要换出页面
    * 页面调入内存后，需要修改相应页表项

### 页面分配策略

* 驻留级大小
* 调入页面的时机
* 从何处调入页面

### 抖动

### 工作集

### 地址翻译

